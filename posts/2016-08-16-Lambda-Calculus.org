---
title: Exploring Lambda Calculus, Part 1
tags: lambda calculus, functional programming
---

* Motivation
I'm currently reading through Greg Michaelson's /An Introduction to Functional Programming Through Lambda Calculus/ [1]. I'm coming to lambda calculus from functional programming; I've been interested in taking a deeper dive into the basis for many functional languages for some time. This post, and likely a few more to come, are my notes and attempts at synthesizing what is in the book.

* Introduction to λ Calculus
Lambda (λ) calculus was discovered by Alonzo Church in 1936. It is a universal model of computation that is equivalent to the Turing machine and Gödel's general recursive functions (the Church-Turing Thesis).

** λ Expressions
#+BEGIN_QUOTE
The λ calculus is a system for manipulating λ expressions. -- /Michaelson 2011, p. 21/
#+END_QUOTE

A λ expression can be either a *name*, *function*, or *function application*.
*** Names
A name is used to refer to a λ expression.
*** Functions
A function is an abstraction over a λ expression that takes the form:
#+BEGIN_SRC latex
fn := λ<name>.<body>
#+END_SRC
*** Function application
Function application is the application of one lambda expression, ~fn~, on a second, ~arg~.
#+BEGIN_SRC latex
  application := (fn arg)
#+END_SRC
** First Example Expressions
For each example, I'll give the λ expression along with examples in Elixir, Haskell, and Python to help explain/build an intuition for what is happening and explore how various programming languages handle anonymous functions.

*** Identity 
The simplest function we can look at is the identity function:
#+BEGIN_SRC latex
λx.x
#+END_SRC

#+BEGIN_SRC elixir
fn x -> x end         #  Elixir
#+END_SRC

#+BEGIN_SRC haskell
\x -> x             -- Haskell
#+END_SRC

#+BEGIN_SRC python
lambda x: x           #  Python
#+END_SRC

Applying the function to an argument returns the argument:

#+BEGIN_SRC latex
(λx.x 5)
5
#+END_SRC

#+BEGIN_SRC elixir
(fn x -> x end).(5)   #  Elixir
5
#+END_SRC

#+BEGIN_SRC haskell
(\x -> x) 5           -- Haskell
5
#+END_SRC

#+BEGIN_SRC python
(lambda x: x)(5)      #  Python
5
#+END_SRC

*** Aside - Naming expressions
We can name expressions to make it easier to refer to them in other expressions. I'll use ~<name> := <expression>~ to name expressions in λ calculus. For Elixir, Haskell, and Python, I'll use language appropriate assignment.

We can name ~identity~  as follows:

#+BEGIN_SRC latex
  identity := λx.x
#+END_SRC

#+BEGIN_SRC elixir :session elixir
  identity = fn x -> x end
#+END_SRC

#+BEGIN_SRC haskell :session haskell
  let identity = \x -> x
#+END_SRC

#+BEGIN_SRC python :session python
  identity = lambda x: x
#+END_SRC

I'll name expressions the first time they appear in the following examples to make it easier to reuse them in the future

*** Self-application

The self-application function is a function that calls itself with itself as the argument:

#+BEGIN_SRC latex
self_apply := λs.(s s)
#+END_SRC

#+BEGIN_SRC elixir :session elixir
self_apply = fn s -> s.(s) end      #  Elixir
#+END_SRC

#+BEGIN_SRC haskell :session haskell
let self_apply = \s -> (s s)        -- Haskell
#+END_SRC

#+BEGIN_SRC python :session python
self_apply = lambda s: s(s)         #  Python
#+END_SRC

Applying the self-application function to the identity function results in the identity function:

#+BEGIN_SRC latex
(λs.(s s) λx.x)
(λx.x λx.x)
λx.x
#+END_SRC

#+BEGIN_SRC elixir
#  Elixir
(fn s -> s.(s) end).(fn x -> x end)
(fn x -> x end).(fn x -> x end)
fn x -> x end
#+END_SRC

#+BEGIN_SRC haskell
-- Haskell
(\s -> (s s)) (\x -> x)
(\x -> x) (\x -> x)
\x -> x
#+END_SRC

#+BEGIN_SRC python
#  Python
(lambda s: s(s))(lambda x: x)
(lambda x: x)(lambda x: x)
lambda x: x
#+END_SRC

Applying the self-application function to itself causes an infinite loop of self-application -- the first step towards building recursive functions:

#+BEGIN_SRC latex
(λs.(s s) λs.(s s))
(λs.(s s) λs.(s s))
.
.
.
#+END_SRC

The argument, =λs.(s s)= is bound in the function =λs.(s s)=, where it replaces the bound variable, /s/, in the function application =(s s)=.

*** Apply

Apply binds a function, /f/, to an expression that binds an argument, /arg/, in an application of /f/ to /arg/. 

#+BEGIN_SRC latex
  apply := λf.λarg.(f arg)
#+END_SRC

#+BEGIN_SRC elixir :session elixir
  apply = fn f -> fn arg -> f.(arg) end end
#+END_SRC

#+BEGIN_SRC haskell :session haskell
  let apply = \f -> \arg -> f arg
#+END_SRC

#+BEGIN_SRC python :session python
  apply = lambda f: lambda arg: f(arg)
#+END_SRC

Applying identity to identity results in the identity function:

#+BEGIN_SRC latex
  (apply identity identity) =>
  ((λf.λarg.(f arg) λx.x) λx.x) =>
  (λarg.(λx.x arg) λx.x) =>
  (λx.x λx.x) =>
  λx.x
#+END_SRC

*** First and Second

We can construct expressions that take two arguments and return either the first or second:

#+BEGIN_SRC latex
first  := λfirst.λsecond.first       # First
second := λfirst.λsecond.second      # Second
#+END_SRC

#+BEGIN_SRC elixir :session elixir
# Elixir
first  = fn first -> fn second -> first end end
second = fn first -> fn second -> second end end
#+END_SRC

#+BEGIN_SRC haskell :session haskell
-- Haskell
let first  = \first -> \second -> first
let second = \first -> \second -> second
#+END_SRC

#+BEGIN_SRC python :session python
#  Python
first  = lambda first: lambda second: first
second = lambda first: lambda second: second
#+END_SRC

*** Make Pair
We can construct functions that take multiple arguments by building an expression that has /n/ + 1 arguments, where /n/ is the number of arguments the function takes:
1. Constructing a function that takes an argument, /x/, and results in a second function, /g/
2. /g/ takes an argument, /y/ and results in a function, /h/ that takes a function as an argument, /z/
3. We apply /z/ to /x/ which returns a function that we apply to /y/
4. This effectively results in /z(x, y)/

#+BEGIN_SRC latex
  make_pair := λx.λy.λz.((z x) y)
#+END_SRC

#+BEGIN_SRC elixir :session elixir
  # Elixir
  make_pair = fn x -> fn y -> fn z -> z.(x).(y) end end end
#+END_SRC

#+BEGIN_SRC haskell :session haskell
  -- Haskell
  let make_pair = \x -> \y -> \z -> z x y
  -- ap (1) (2) (\x y -> x > y)
#+END_SRC

#+BEGIN_SRC python :session python
  #  Python
  make_pair = lambda x: lambda y: lambda z: z(x)(y)
#+END_SRC
*** Free and Bound Variables
Variables are bound based on the scope in which they occur.
***** TODO
** α Conversion, β Reduction, η Reduction
*** α conversion
Alpha (α) conversion is the process of renaming variables in expressions to prevent collisions.

#+BEGIN_SRC latex
  (λx.λy.(x y) λx.x)
#+END_SRC

In this example, the function =λx.λy.(x y)= and the argument =λx.x= both contain the variable /x/ bound in different scopes. We can rename the /x/ in either of the expressions to avoid confusion:

#+BEGIN_SRC latex
  (λx.λy.(x y) λx.x) ==
  (λx.λy.(x y) λz.z)
#+END_SRC

*** β reduction
Beta (β) reduction is the substitution of a variable through function application; in the preceeding examples, every time ~=>~ appeard, it was an indication of β reduction:

#+BEGIN_SRC latex
  ((λf.λarg.(f arg) λx.x) λx.x) =>  # β reduction substituting the first argument, λx.x in the first function aplication
  (λarg.(λx.x arg) λx.x) =>         # substituting the argument, λx.x in the function application
  (λx.x λx.x) =>                    # substituting the argument λx.x in the function application (λx.x λx.x)
  λx.x                              # Final result of β reducing the original expression 
#+END_SRC

*** η reduction
**** TODO Don't fully understand the explanation for  η reduction
Eta (η) reduction is another means of simplifying an expression.

An expression, ~λarg.(f arg)~, η reduces to ~f~. This works because we can freely build applications that take an arbitrary argument by binding an argument in the application:

#+BEGIN_SRC latex
  f -> λarg.(f arg)
#+END_SRC
** Conditions, Booleans, and Numbers
We can use λ calculus to work with Boolean logic. To frame the way we're implementing logic, we can look at a Haskell src_haskell{if <condition> then <expression 1> else <expression 2>} conditional and a C style ternary conditional, src_C{<condition> ? <expression 1> : <expression 2>}. 

In both cases, we have an expression that takes three arguments, =<condition>=, =<expression 1>=, and =<expression 2>=.  

Based on whether =<condition>= is src_haskell{true} or src_haskell{false}, we proceed with =<expression 1>= or =<expression 2>= respectively.

These can be implemented via expressions we've already seen:

*** Conditional
The entire src_haskell{if <condition> then <expression 1> else <expression 2>} or src_C{<condition> ? <expression 1> : <expression 2>} is =make_pair=:

#+BEGIN_SRC latex
  λx.λy.λz.((z x) y) ≡ λexpression1.λexpression2.λcondition.((condition expression1) expression2)

  cond := λexpression1.λexpression2.λcondition.((condition expression1) expression2)
#+END_SRC

*** True/False

Given that if =<condition>= is =true= we proceed with =<expression 1>=, =first= is equivalent to =true=:

#+BEGIN_SRC latex
  true := λfirst.λsecond.first
#+END_SRC

Given that if =<condition>= is false, we proceed with =<expression 2>=, =second= is equivalent to =false=:

#+BEGIN_SRC latex
  false := λfirst.λsecond.second
#+END_SRC

*** Example

With an arbitrary =<expression 1>= and =<expression 2>=, we can run through a reduction of =cond=.

#+BEGIN_SRC latex
  ((cond <expression 1>) <expression 2>) =>
  ((λexpression1.λexpression2.λcondition.((condition expression1) expression2) <expression 1>) <expression 2>) =>
  (λexpression2.λcondition.((condition <expression 1>) expression2) <expression 2>) =>
  λcondition.((condition <expression 1>) <expression2>)
#+END_SRC

We can then apply =true= and =false= to see how they determine which expression we proceed with:

#+BEGIN_SRC latex
  (λcondition.((condition <expression 1>) <expression2>) true) =>
  (λcondition.((condition <expression 1>) <expression2>) λfirst.λsecond.first) =>
  ((λfirst.λsecond.first <expression 1>) <expression 2>) =>
  (λsecond.<expression 1> <expression 2>) =>
  <expression 1>
#+END_SRC

#+BEGIN_SRC latex
  (λcondition.((condition <expression 1>) <expression2>) false) =>
  (λcondition.((condition <expression 1>) <expression2>) λfirst.λsecond.second) =>
  ((λfirst.λsecond.second <expression 1>) <expression 2>) =>
  (λsecond.second <expression 2>) =>
  <expression 2>
#+END_SRC
*** Logical Operators: NOT, AND, OR
**** NOT
=NOT= is the negation operator: ~NOT TRUE == FALSE~ and ~NOT FALSE == TRUE~.

This is another conditional expression: src_haskell{not = if true then false else true}. We can therefore use another conditional to implement this behavior:

#+BEGIN_SRC latex
  not := (λc.(c false) true)
#+END_SRC

We can apply =not= to =true= and =false= and see that we get the expected results:

#+BEGIN_SRC latex
  (not true) =>
  (λc.((c false) true) true) =>
  (λc.((c false) true) λfirst.λsecond.first) =>
  ((λfirst.λsecond.first false) true) =>
  (λsecond.false true) =>
  false
#+END_SRC

#+BEGIN_SRC latex
  (not false) =>
  (λc.((c false) true) false) =>
  (λc.((c false) true) λfirst.λsecond.second) =>
  ((λfirst.λsecond.second false) true) =>
  (λsecond.second true) =>
  true
#+END_SRC
**** AND
**** OR
* Footnotes
[1] Michaelson, Greg. /An Introduction to Functional Programming Through Lambda Calculus/. Dover, 2011.


